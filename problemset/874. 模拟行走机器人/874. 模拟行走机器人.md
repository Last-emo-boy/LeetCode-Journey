#### [874. 模拟行走机器人](https://leetcode.cn/problems/walking-robot-simulation/)

难度中等

机器人在一个无限大小的 XY 网格平面上行走，从点 `(0, 0)` 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 `commands` ：

- `-2` ：向左转 `90` 度
- `-1` ：向右转 `90` 度
- `1 <= x <= 9` ：向前移动 `x` 个单位长度

在网格上有一些格子被视为障碍物 `obstacles` 。第 `i` 个障碍物位于网格点  `obstacles[i] = (xi, yi)` 。

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 `5` ，则返回 `25` ）

**注意：**

- 北表示 `+Y` 方向。
- 东表示 `+X` 方向。
- 南表示 `-Y` 方向。
- 西表示 `-X` 方向。

**示例 1：**

**输入：**commands = [4,-1,3], obstacles = []
**输出：**25
**解释：** 机器人开始位于 (0, 0)：

1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 3 个单位，到达 (3, 4)
  距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25

**示例 2：**

**输入：**commands = [4,-1,4,-2,4], obstacles = [[2,4]]
**输出：**65
**解释**：机器人开始位于 (0, 0)：

1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)
4. 左转
5. 向北走 4 个单位，到达 (1, 8)
  距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65

**提示：**

- `1 <= commands.length <= 104`
- `commands[i]` is one of the values in the list `[-2,-1,1,2,3,4,5,6,7,8,9]`.
- `0 <= obstacles.length <= 104`
- `-3 * 104 <= xi, yi <= 3 * 104`
- 答案保证小于 `231`

这个问题需要我们模拟机器人的移动，并在遇到障碍物时正确地处理。我们首先需要了解一些基本的概念：

1. 机器人可以向前移动指定的单位长度，也可以左转或右转90度。
2. 机器人不能进入有障碍物的格子，它会在障碍物前的格子停下来。
3. 我们需要返回机器人在所有经过的路径点中，与原点的最大欧氏距离的平方。

有几个关键的点需要注意：

1. 机器人的方向：我们可以设置一个方向数组，例如 `dx = [0, 1, 0, -1]` 和 `dy = [1, 0, -1, 0]`，表示北，东，南，西四个方向的变化。初始时，机器人面向北，我们可以设置一个变量 `d` 表示当前的方向，初始化为0。当命令为-1时，向右转90度，方向变为 `(d + 1) % 4`；当命令为-2时，向左转90度，方向变为 `(d - 1) % 4`。
2. 机器人的移动：当命令为1-9之间的数字 `x` 时，机器人需要向当前方向移动 `x` 个单位长度。我们需要遍历 `x`，对于每一步，先判断是否会遇到障碍物，如果会，则停止移动；否则，更新位置和最大欧氏距离的平方。

我们可以先将障碍物的坐标放入一个集合 `obs` 中，这样我们可以在O(1)的时间内判断一个坐标是否是障碍物。

以下是Python代码实现：

```python
from typing import List

class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        d = 0
        x = y = 0
        result = 0
        obs = set(map(tuple, obstacles))
        for command in commands:
            if command == -1:
                d = (d + 1) % 4
            elif command == -2:
                d = (d - 1) % 4
            else:
                for _ in range(command):
                    if (x + dx[d], y + dy[d]) not in obs:
                        x += dx[d]
                        y += dy[d]
                        result = max(result, x * x + y * y)
                    else:
                        break
        return result

```